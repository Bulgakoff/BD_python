


use shop;
-- Практическое задание по теме “Операторы, фильтрация, сортировка и ограничение”
-- -----------------------------------------------------------------------------------
-- 1. Пусть в таблице users поля created_at и updated_at оказались незаполненными. 
-- Заполните их текущими датой и временем.
INSERT INTO shop.users
(name, brithday_at, created_at, updated_at)
VALUES('Толя', '1973-04-18', now(), now()),
	('Гена', '1978-04-10', now(), now());
SELECT *FROM shop.users;
-- |  6 | Тема       | 1933-07-28  | 2020-05-06 12:30:52 | 2020-05-06 12:30:52 |
-- |  7 | Вова       | 1974-08-18  | 2020-05-06 12:30:52 | 2020-05-06 12:30:52 |
-- |  8 | Маша       | 2014-04-19  | 2020-05-06 12:30:52 | 2020-05-06 12:30:52 |
-- ниже добавленные пользователи:
-- |  9 | Толя       | 1973-04-18  | 2020-05-06 13:22:02 | 2020-05-06 13:22:02 |
-- | 10 | Гена       | 1978-04-10  | 2020-05-06 13:22:02 | 2020-05-06 13:22:02 |
-- +----+------------+-------------+---------------------+---------------------+
-- ---------------------------------------------------------------------------------------
-- 2. Таблица users была неудачно спроектирована. 
-- Записи created_at и updated_at были заданы типом VARCHAR 
-- и в них долгое время помещались значения в формате "20.10.2017 8:10". 
-- Необходимо преобразовать поля к типу DATETIME, сохранив введеные ранее значения.

drop table if exists users2;
create table users2(
  id SERIAL primary key,
  name varchar(255) comment 'Имя покупателя',
  brithday_at date comment 'дата рождения',
  created_at varchar(100) comment 'varchar неправильно -- время регистрации',
  updated_at varchar(100) comment 'varchar неправильно === ремя пос обновления' 
)COMMENT = 'Покупателя';
INSERT INTO shop.users2
(name, brithday_at, created_at, updated_at)
VALUES('Толя', '1979-05-18', '20.10.2017 8:10','20.10.2017 8:10'),
		('Муля', '1973-04-18', '20.10.2017 8:10','20.10.2017 8:10'),
		('Соня', '1953-08-18', '20.10.2017 8:10','20.10.2017 8:10'),
		('ВОля', '1983-04-18', '20.10.2017 8:10','20.10.2017 8:10'),
      ('Джон', '2004-06-15', '20.10.2017 8:10','20.10.2017 8:10');
SELECT *FROM shop.users2;
-- +----+----------+-------------+-----------------+-----------------+
-- | id | name     | brithday_at | created_at      | updated_at      |
-- +----+----------+-------------+-----------------+-----------------+
-- |  1 | Толя     | 1973-04-18  | 20.10.2017 8:10 | 20.10.2017 8:10 |
-- |  2 | Джон     | 2004-06-15  | 20.10.2017 8:10 | 20.10.2017 8:10 |
-- +----+----------+-------------+-----------------+-----------------+
-- SELECT UNIX_TIMESTAMP(created_at) as TIMESTAMP,
-- 		FROM_UNIXTIME(NOW()) as DATETIME FROM users2;

-- тут не разобрался <--===================================================|

-- ---------------------------------------------------------------------------------------
-- 3.В таблице складских запасов storehouses_products в поле value 
-- могут встречаться самые разные цифры: 0, если товар закончился 
-- и выше нуля, если на складе имеются запасы. Необходимо отсортировать 
-- записи таким образом, чтобы они выводились в порядке увеличения
-- значения value. Однако, нулевые запасы должны выводиться в конце, 
-- после всех записей.
drop table if exists store_house_products2;
create table store_house_products2(
  id SERIAL primary KEY,
--   users_id int unsigned,
--   id_store_house_products int unsigned,
  products_id int unsigned,
  value int unsigned comment 'Запас тованой позиции хранимый на складе',
  created_at datetime default CURRENT_TIMESTAMP comment 'время регистрации',
  updated_at datetime  default CURRENT_TIMESTAMP   on update  CURRENT_TIMESTAMP
) COMMENT = 'Запасы на складе';



INSERT INTO shop.store_house_products2
(products_id,value, created_at, updated_at) VALUES 
(1,67,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
(2,0,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
(8,0,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
(5,50,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
(10,70,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP); 
SELECT *FROM store_house_products2 ;
-- +----+-------------+-------+---------------------+---------------------+
-- | id | products_id | value | created_at          | updated_at          |
-- +----+-------------+-------+---------------------+---------------------+
-- |  1 |           1 |    67 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- |  2 |           2 |     0 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- |  3 |           8 |     0 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- |  4 |           5 |    50 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- |  5 |          10 |    70 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- +----+-------------+-------+---------------------+---------------------+
-- 5 rows in set
-- сортируем запасы:
SELECT* FROM shop.store_house_products2 ORDER by value desc,id desc ;

-- +----+-------------+-------+---------------------+---------------------+
-- | id | products_id | value | created_at          | updated_at          |
-- +----+-------------+-------+---------------------+---------------------+
-- |  5 |          10 |    70 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- |  1 |           1 |    67 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- |  4 |           5 |    50 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- |  3 |           8 |     0 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- |  2 |           2 |     0 | 2020-05-06 17:04:45 | 2020-05-06 17:04:45 |
-- +----+-------------+-------+---------------------+---------------------+
-- &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&/
-- не разобралься как отсортировать только часть таблицы, сохранив нули в конце.
-- ------------------------------------------------------------------------------------
-- 3. (по желанию) Из таблицы users2 необходимо извлечь пользователей, 
-- родившихся в августе и мае. Месяцы заданы в виде списка английских
-- названий ('may', 'august')
SELECT id,name, brithday_at FROM shop.users2 

-- +----+----------+-------------+
-- | id | name     | brithday_at |
-- +----+----------+-------------+
-- |  1 | Толя     | 1979-05-18  |
-- |  2 | Муля     | 1973-04-18  |
-- |  3 | Соня     | 1953-08-18  |
-- |  4 | ВОля     | 1983-04-18  |
-- |  5 | Джон     | 2004-06-15  |
-- +----+----------+-------------+

SELECT id,name, brithday_at FROM shop.users2  where brithday_at  LIKE '_____05%';

-- +----+----------+-------------+
-- | id | name     | brithday_at |
-- +----+----------+-------------+
-- |  1 | Толя     | 1979-05-18  |
-- +----+----------+-------------+
SELECT id,name, brithday_at FROM shop.users2  where brithday_at  LIKE '_____04%';

-- +----+----------+-------------+
-- | id | name     | brithday_at |
-- +----+----------+-------------+
-- |  2 | Муля     | 1973-04-18  |
-- |  4 | ВОля     | 1983-04-18  |
-- ???????????????????????????????????????
-- 5. (по желанию) Из таблицы catalogs извлекаются записи при помощи запроса.
-- SELECT * FROM catalogs WHERE id IN (5, 1, 2); 
-- Отсортируйте записи в порядке, заданном в списке IN.

SELECT * FROM catal WHERE id IN (5, 1, 2) ORDER BY FIELD(5,1,2);  
-- +----+-------------------------------------+
-- | id | name                                |
-- +----+-------------------------------------+
-- |  1 | proccessors                         |
-- |  2 | mat.platy                           |
-- |  5 | оперативная память                  |
-- +----+-------------------------------------+

-- Практическое задание теме “Агрегация данных”
-- 1.Подсчитайте средний возраст пользователей в таблице users2

SELECT 
name,brithday_at,
timestampdiff(YEAR,brithday_at,NOW()) as age FROM users2;
-- +----------+-------------+------+
-- | name     | brithday_at | age  |
-- +----------+-------------+------+
-- | Толя     | 1979-05-18  |   40 |
-- | Муля     | 1973-04-18  |   47 |
-- | Соня     | 1953-08-18  |   66 |
-- | ВОля     | 1983-04-18  |   37 |
-- | Джон     | 2004-06-15  |   15 |
-- +----------+-------------+------+

SELECT ROUND(AVG(timestampdiff(YEAR,brithday_at,NOW())),1)  as age FROM users2;
-- +------+
-- | age  |
-- +------+
-- | 41.0 |
-- +------+

-- 
-- 2.Подсчитайте количество дней рождения, 
-- которые приходятся на каждый из дней недели. 
-- Следует учесть, что необходимы дни недели текущего года, а не года рождения.,

select DAYOFWEEK(MAKEDATE(Year(now()),DAYOFYEAR(brithday_at)))
as BirthdayOfWeek, count(*)
from users2 Group by BirthdayOfWeek
Order by 1;




-- 3.(по желанию) Подсчитайте произведение чисел в столбце таблицы

select ROUND( exp(sum(ln(id))),2) from users2;
-- +----------------------------+
-- | ROUND( exp(sum(ln(id))),2) |
-- +----------------------------+
-- |                     120.00 |
-- +----------------------------+

